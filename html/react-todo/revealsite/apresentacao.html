<!DOCTYPE html>
<html lang="pt-br">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css" />
    <link rel="stylesheet" href="dist/reveal.css" />
    <link rel="stylesheet" href="dist/theme/white.css" />

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css" />
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
        <section>
          <div>
            <h2>Gerenciador de Tarefas</h2>
          </div>
          <div style="margin-top: 2rem">
            <p><strong>Grupo 53 - INE5646 Programação para Web</strong></p>
            <p>
              <small>
                Eduardo Wallner Giacomelli<br />
                Matias Adrian Fuks
              </small>
            </p>
          </div>
        </section>

        <section>
          <h3>Introdução e Motivação</h3>
          <a href="https://ine5646.e.w.giacomelli.vms.ufsc.br"></a>
        </section>

        <section>
          <section>
            <h3>Visão Geral das Tecnologias</h3>
            <section>
              <h4>Stack MERN:</h4>

              <ul>
                <li>Backend: Node.js com Express.js.</li>
                <li>Frontend: React com Vite e TypeScript.</li>
                <li>
                  Banco de Dados: MongoDB, hospedado na nuvem com MongoDB Atlas.
                </li>
                <li>
                  Estilo: Pico.css, com forte ênfase no uso de HTML semântico e
                  mínimas customizações.
                </li>
              </ul>
            </section>
            <section>
              <h4>Ambiente de Deploy:</h4>
              <ul>
                <li>Servidor VPS da UFSC (Ubuntu).</li>
                <li>
                  Servidor Web: Apache2, que atuará como servidor para os
                  arquivos estáticos do frontend e como proxy reverso para a API
                  do backend.
                </li>
                <li>
                  Gerenciador de Processos do Backend: PM2, para manter o
                  servidor Node.js a rodar 24/7.
                </li>
              </ul>
            </section>
          </section>

          <section>
            <h4>Backend</h4>
            <p><strong>Arquitetura MERN e o Padrão RESTful</strong></p>
            <ul>
              <li>
                Lida com a lógica de negócio, validação de dados e comunicação
                com o banco de dados.
              </li>
              <li>
                Autenticação: Utiliza JSON Web Tokens (JWT). No login/registo,
                um token é gerado com uma JWT_SECRET e enviado para o frontend.
                A senha do usuário é armazenada no banco de dados de forma
                segura usando hashing e salting com bcryptjs.
              </li>
              <li>
                Estrutura de Pastas: models (schemas Mongoose), controllers
                (lógica), routes (endpoints), middleware (autenticação com
                protect e tratamento de erros).
              </li>
            </ul>
          </section>
        </section>

        <section>
          <section>
            <h3>Frontend Single Page Application (SPA)</h3>
            <p>
              Ao acessar o site o cliente recebe todo html do site, e o React é
              responsável por cuidar das rotas aliviando a carga do servidor.
            </p>
          </section>

          <section>
            <h4>Comunicação com API:</h4>
            <p>
              Usa axios. Um serviço api.ts centraliza a configuração, definindo
              a baseURL e usando um interceptor de requisição para adicionar
              automaticamente o Bearer Token (JWT) a todos os pedidos para rotas
              protegidas.
            </p>
            <pre
              class="fragment"
            ><code data-line-numbers="17-21" class="language-javascript" style="max-height: 350px;">
// 
const api = axios.create({
  baseURL: API_BASE_URL,
  headers: {
    'Content-Type': 'application/json',
  },
  timeout: 10000,
});

api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('authToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    console.error('Erro no intercetor de requisição Axios:', error);
    return Promise.reject(error);
  }
);
        </code></pre>
          </section>

          <section>
            <h4>Gerenciamento de Estado:</h4>
            <ul>
              <li>
                <h5>Estado Global de Autenticação:</h5>
                <p>
                  Gerido pelo AuthContext.tsx. Ele guarda o token e os dados do
                  usuário, provendo um estado isAuthenticated para toda a
                  aplicação. O token JWT é guardado no localStorage do navegador
                  para persistir a sessão.
                </p>
              </li>
              <li>
                <h5>Estado Local:</h5>
                <p>
                  Componentes usam useState para gerir UI local (ex: dados de
                  formulários, visibilidade de modais).
                </p>
              </li>
              <li>
                <h5>Roteamento:</h5>
                <p>
                  Usa react-router-dom com componentes customizados
                  (ProtectedRoute, PublicOnlyRoute, RootPageDecider) para
                  controlar o acesso às páginas com base no estado de
                  autenticação.
                </p>
              </li>
            </ul>

            <pre
              class="fragment"
            ><code data-line-numbers="5-10" class="language-javascript" style="max-height: 400px;">
// controllers/taskController.js
exports.createTask = async (req, res) => {
  const { title, assignedMemberIds = [] } = req.body;
  const userId = req.user.id;

  try {
    // Validação de segurança: o membro pertence ao usuário?
    if (assignedMemberIds.length > 0) {
      const members = await Member.find({
        '_id': { $in: assignedMemberIds },
        createdByUserId: userId
      });
      if (members.length !== assignedMemberIds.length) {
        return res.status(404).json({ message: 'Membro inválido.' });
      }
    }
    // ... Lógica para salvar a tarefa ...
  } catch (error) { // ... }
};
        </code></pre>
          </section>

          <section>
            <h4>2. Controllers (A Lógica de Negócio)</h4>
            <p>
              Onde a "mágica" acontece. Funções que recebem pedidos, processam
              dados e interagem com os Modelos.
            </p>

            <pre
              class="fragment"
            ><code data-line-numbers="5-10" class="language-javascript" style="max-height: 400px;">
// controllers/taskController.js
exports.createTask = async (req, res) => {
  const { title, assignedMemberIds = [] } = req.body;
  const userId = req.user.id;

  try {
    // Validação de segurança: o membro pertence ao usuário?
    if (assignedMemberIds.length > 0) {
      const members = await Member.find({
        '_id': { $in: assignedMemberIds },
        createdByUserId: userId
      });
      if (members.length !== assignedMemberIds.length) {
        return res.status(404).json({ message: 'Membro inválido.' });
      }
    }
    // ... Lógica para salvar a tarefa ...
  } catch (error) { // ... }
};
        </code></pre>
          </section>

          <section>
            <h4>3. Rotas e Middlewares (O Fluxo de Pedidos)</h4>
            <p>
              Mapeiam as URLs da API para os Controladores e atuam como
              "seguranças" nas portas de entrada.
            </p>

            <pre
              class="fragment"
            ><code data-line-numbers="12-14" class="language-javascript">
// routes/taskRoutes.js
router.route('/')
  .post(protect, createTask)  // Rota protegida
  .get(protect, getUserTasks); // Rota protegida

router.route('/:id')
  .put(protect, updateTask)   // Rota protegida
  .delete(protect, deleteTask); // Rota protegida
        </code></pre>

            <p class="fragment">
              O middleware `protect` é executado antes de cada função do
              controlador, validando o Token JWT e garantindo que apenas
              usuários autenticados possam prosseguir.
            </p>
          </section>
        </section>

        <section>
          <h3>Segurança e Autenticação</h3>
          <p>
            A segurança da aplicação é baseada em dois pilares: Hashing de
            Senhas e JSON Web Tokens (JWT).
          </p>
          <div class="fragment">
            <p>
              <strong>Hashing com `bcryptjs`:</strong> As senhas nunca são
              armazenadas. Guardamos apenas um hash criptográfico com "salt",
              tornando ataques de força bruta inviáveis.
            </p>
            <p>
              <strong>JWT Stateless:</strong> Após o login, o servidor gera um
              token assinado. Cada pedido subsequente a uma rota protegida deve
              conter este token, que é validado pelo backend, garantindo uma
              autenticação segura sem armazenar sessões no servidor.
            </p>
          </div>
        </section>
      </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
      // More info about initialization & config:
      // - https://revealjs.com/initialization/
      // - https://revealjs.com/config/
      Reveal.initialize({
        hash: true,
        progress: true,
        slideNumber: "c/t",

        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes],
      });
    </script>
  </body>
</html>
