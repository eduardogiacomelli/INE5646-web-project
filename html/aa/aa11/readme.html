<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AA11: Monitor de Mensagens TCP/UDP com WebSocket - Documenta√ß√£o</title>
  <link rel="stylesheet" href="style.css"> <style>
    /* Additional styles specific to aa11.html for code blocks and layout */
    .code-block {
      background-color: #2d2d2d; /* Dark background for code */
      color: #f0f0f0; /* Light text for code */
      padding: 15px;
      border-radius: 5px;
      margin-bottom: 15px;
      overflow-x: auto;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9em;
    }
    .code-block pre {
      margin: 0;
      white-space: pre-wrap; /* Wrap long lines */
      word-break: break-all;
    }
    .code-block .comment {
      color: #7f8c8d; /* Grey for comments */
    }
    .code-block .keyword {
      color: #c37bd6; /* Purple for keywords */
      font-weight: bold;
    }
    .code-block .string {
      color: #7ec699; /* Green for strings */
    }
    .code-block .function {
      color: #61afef; /* Blue for functions */
    }
    .code-block .variable {
      color: #e06c75; /* Red for variables/constants */
    }
    .file-path {
      background-color: #e0e0e0;
      color: #333;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: monospace;
    }
    main section h3 { /* Make H3 within sections slightly smaller or styled differently */
        font-size: 1.6rem;
        color: #250966; /* Match header color for emphasis */
        margin-top: 1.5rem;
        margin-bottom: 0.8rem;
        border-bottom: 2px solid #ede7f6;
        padding-bottom: 0.3rem;
    }
    dt {
        font-weight: bold;
        color: #2c3e50;
        margin-top: 0.5em;
    }
    dd {
        margin-left: 20px;
        margin-bottom: 0.5em;
    }
  </style>
</head>
<body>
  <header>
    <h1>AA11: Monitor de Mensagens TCP/UDP com WebSocket</h1>
    <p>Documenta√ß√£o e Roteiro de Implementa√ß√£o</p>
  </header>

  <nav>
    <ul>
      <li><a href="index.html">AA11</a></li>
      <li><a href="#intro">Introdu√ß√£o</a></li>
      <li><a href="#prerequisitos">Pr√©-requisitos</a></li>
      <li><a href="#config-servidor">Configura√ß√£o do Servidor</a></li>
      <li><a href="#estrutura-projeto">Estrutura do Projeto</a></li>
      <li><a href="#backend">Backend (Python)</a></li>
      <li><a href="#frontend">Frontend (HTML/JS)</a></li>
      <li><a href="#execucao">Execu√ß√£o</a></li>
      <li><a href="#deploy-edicao">Deploy e Edi√ß√£o</a></li>
      <li><a href="#bonus-wss">B√¥nus: WSS</a></li>
    </ul>
  </nav>

  <main>
    <section id="intro">
      <h2><emoji>üéØ</emoji> Introdu√ß√£o</h2>
      <div class="card-container">
        <article class="card">
          <h3>Sobre a Atividade Avaliativa 11</h3>
          <p>
            Esta atividade consiste em implementar um <strong>Monitor de Mensagens TCP e UDP</strong> no servidor virtual da UFSC (VPS-UFSC). O objetivo √© capturar mensagens enviadas por clientes TCP e UDP em portas espec√≠ficas e exibi-las em tempo real em uma p√°gina web utilizando WebSockets.
          </p>
          <p>
            A p√°gina web dever√° apresentar o status do servidor, os controles para iniciar/parar o monitoramento (ou a conex√£o), limpar mensagens, e uma √°rea para visualiza√ß√£o das mensagens recebidas, com filtros e contadores.
          </p>
          <p><strong>URL do Servidor HTTP/WebSocket:</strong> <code class="file-path">websocket.idUFSC.vms.ufsc.br</code></p>
        </article>
      </div>
    </section>

    <hr>

    <section id="prerequisitos">
      <h2><emoji>üõ†Ô∏è</emoji> Pr√©-requisitos</h2>
      <div class="card-container">
        <article class="card">
          <h3>Requisitos Necess√°rios</h3>
          <ul>
            <li>Acesso ao servidor virtual da UFSC (VPS-UFSC) via <a href="https://idufsc.ufsc.br/cloud/vps" target="_blank">idUFSC Cloud</a>.</li>
            <li>Cliente SSH para acessar o VPS.</li>
            <li>Conex√£o √† VPN da UFSC (necess√°ria caso esteja acessando de fora da rede da UFSC).</li>
            <li>Python 3 e pip instalados no VPS.</li>
            <li>Navegador web moderno para testar a interface.</li>
            <li>Os arquivos fornecidos: <code class="file-path">tcp_client.py</code>, <code class="file-path">udp_client.py</code>, e <code class="file-path">ws.css</code>.</li>
          </ul>
        </article>
      </div>
    </section>

    <hr>

    <section id="config-servidor">
      <h2><emoji>üñ•Ô∏è</emoji> Configura√ß√£o do Servidor (VPS-UFSC)</h2>
      <div class="card-container">
        <article class="card">
          <h3>3.1. Acesso ao VPS</h3>
          <p>Primeiramente, conecte-se ao seu VPS. Se estiver fora da rede da UFSC, conecte-se √† VPN da UFSC.</p>
          <p>Use o comando SSH (substitua <code class="file-path">seu_idUFSC</code> pelo seu identificador):</p>
          <div class="code-block">
            <pre>ssh -4XC seu_idUFSC@websocket.seu_idUFSC.vms.ufsc.br</pre>
          </div>
          <ul>
              <li><code class="file-path">-4</code>: For√ßa o uso de IPv4.</li>
              <li><code class="file-path">-X</code>: Habilita o encaminhamento X11 (√∫til para aplica√ß√µes gr√°ficas, mas n√£o estritamente necess√°rio aqui).</li>
              <li><code class="file-path">-C</code>: Habilita a compress√£o, o que pode acelerar a conex√£o.</li>
          </ul>
          <p>Para nosso exemplo: <code class="file-path">ssh -4XC e.w.giacomelli@websocket.e.w.giacomelli.vms.ufsc.br</code></p>
        </article>

        <article class="card">
          <h3>3.2. Instala√ß√£o de Software</h3>
          <p>No VPS, atualize a lista de pacotes e instale o Apache2, Python 3, pip, e a biblioteca Python `websockets`:</p>
          <div class="code-block">
            <pre>
sudo apt update
sudo apt install apache2
sudo apt install python3 python3-pip
sudo apt install python3-websockets
            </pre>
          </div>
        </article>

        <article class="card">
            <h3>3.3. Configura√ß√£o do Apache2</h3>
            <p>
                O Apache2 servir√° a p√°gina <code class="file-path">index.html</code> (a interface do monitor) na porta 80. Ele tamb√©m pode ser configurado como um reverse proxy para o servidor WebSocket que rodar√° na porta 8082, permitindo que as conex√µes WebSocket passem pela porta 80 (ex: <code class="file-path">ws://websocket.seu_idUFSC.vms.ufsc.br/ws</code>). No entanto, a especifica√ß√£o da atividade indica que o WebSocket Server usar√° a porta 8082 diretamente.
            </p>
            <p>
                Vamos configurar o Apache para servir os arquivos est√°ticos e habilitar CGI para os scripts de controle do servidor Python, conforme sugerido na estrutura do servidor.
            </p>
            <p>Edite o arquivo de configura√ß√£o do site padr√£o do Apache:</p>
            <div class="code-block"><pre>sudo nano /etc/apache2/sites-available/000-default.conf</pre></div>
            <p>Adicione/modifique a se√ß√£o <code class="file-path">&lt;Directory "/var/www/html"&gt;</code> e, se for usar CGI para controle do servidor, configure o diret√≥rio dos scripts CGI. A atividade sugere que os scripts Python (.py) sejam tratados como CGI no diret√≥rio <code class="file-path">/var/www/html</code> ou um subdiret√≥rio.</p>

            <p>Configura√ß√£o sugerida para <code class="file-path">000-default.conf</code> (mantenha outras configura√ß√µes existentes, como <code class="file-path">ServerAdmin</code> e <code class="file-path">DocumentRoot</code>):</p>
            <div class="code-block">
            <pre><span class="keyword">&lt;VirtualHost *:80&gt;</span>
    ServerName websocket.seu_idUFSC.vms.ufsc.br
    DocumentRoot /var/www/html

    ErrorLog ${APACHE_LOG_DIR}/error.log
    CustomLog ${APACHE_LOG_DIR}/access.log combined

    <span class="comment"># Configura√ß√£o para servir arquivos est√°ticos e o index.html principal</span>
    <span class="keyword">&lt;Directory "/var/www/html"&gt;</span>
        Options -Indexes +FollowSymLinks <span class="comment"># +ExecCGI se os scripts CGI estiverem aqui</span>
        DirectoryIndex index.html
        AllowOverride None
        Require all granted
        <span class="comment"># Se for usar scripts .py diretamente em /var/www/html como CGI</span>
        <span class="comment"># AddHandler cgi-script .py</span>
        <span class="comment"># Options +ExecCGI</span>
    <span class="keyword">&lt;/Directory&gt;</span>

    <span class="comment"># Configura√ß√£o para scripts CGI em um diret√≥rio espec√≠fico (ex: /var/www/html/py/)</span>
    <span class="comment"># Isso √© √∫til se os scripts de controle do servidor (start/stop/status) forem CGI.</span>
    ScriptAlias /cgi-bin/ /var/www/html/py/
    <span class="keyword">&lt;Directory "/var/www/html/py/"&gt;</span>
        Options +ExecCGI -Indexes
        AddHandler cgi-script .py
        Require all granted
        AllowOverride None
    <span class="keyword">&lt;/Directory&gt;</span>

    <span class="comment"># Se voc√™ quiser usar Apache como proxy reverso para o WebSocket na porta 8082</span>
    <span class="comment"># para que o cliente conecte em ws://your_domain/ws em vez de ws://your_domain:8082</span>
    <span class="comment"># ProxyPreserveHost On</span>
    <span class="comment"># ProxyRequests Off</span>
    <span class="comment"># ProxyPass /ws ws://127.0.0.1:8082/</span>
    <span class="comment"># ProxyPassReverse /ws ws://127.0.0.1:8082/</span>
<span class="keyword">&lt;/VirtualHost&gt;</span></pre>
            </div>
            <p>Habilite os m√≥dulos necess√°rios (cgi se for usar, proxy_wstunnel se for usar proxy):</p>
            <div class="code-block"><pre>
sudo a2enmod cgid <span class="comment"># Se usar CGI para scripts Python de controle</span>
<span class="comment"># sudo a2enmod proxy proxy_http proxy_wstunnel # Se usar Apache como proxy para WebSocket</span>
sudo systemctl restart apache2</pre>
            </div>
            <p><strong>Nota sobre o Servidor WebSocket:</strong> O servidor WebSocket principal (<code class="file-path">websocket_server.py</code>) rodar√° como um processo Python separado na porta 8082. Os scripts CGI (<code class="file-path">start_server.py</code>, <code class="file-path">stop_server.py</code>, <code class="file-path">status_server.py</code>) podem ser usados para controlar este processo atrav√©s de requisi√ß√µes HTTP feitas pelo JavaScript da p√°gina <code class="file-path">index.html</code>.</p>
        </article>
      </div>
    </section>

    <hr>

    <section id="estrutura-projeto">
      <h2><emoji>üìÅ</emoji> Estrutura do Projeto (no Servidor)</h2>
      <div class="card-container">
        <article class="card">
          <h3>Organiza√ß√£o dos Arquivos</h3>
          <p>A estrutura de arquivos no servidor (<code class="file-path">/var/www/html/</code>) ser√° a seguinte:</p>
          <div class="code-block"><pre>
/var/www/html/
‚îú‚îÄ‚îÄ index.html         <span class="comment"># P√°gina principal da atividade (monitor de mensagens)</span>
‚îú‚îÄ‚îÄ css/
‚îÇ   ‚îî‚îÄ‚îÄ ws.css         <span class="comment"># Estilos fornecidos para a p√°gina do monitor</span>
‚îú‚îÄ‚îÄ js/
‚îÇ   ‚îî‚îÄ‚îÄ ws.js          <span class="comment"># L√≥gica JavaScript para o monitor</span>
‚îî‚îÄ‚îÄ py/                <span class="comment"># Scripts Python</span>
    ‚îú‚îÄ‚îÄ websocket_server.py <span class="comment"># Servidor WebSocket principal (escuta em 8080 TCP, 8081 UDP, 8082 WS)</span>
    ‚îú‚îÄ‚îÄ start_server.py     <span class="comment"># CGI para iniciar o websocket_server.py</span>
    ‚îú‚îÄ‚îÄ stop_server.py      <span class="comment"># CGI para parar o websocket_server.py</span>
    ‚îî‚îÄ‚îÄ status_server.py    <span class="comment"># CGI para verificar o status do websocket_server.py</span>
          </pre></div>
          <p>Crie os diret√≥rios:</p>
          <div class="code-block"><pre>
sudo mkdir -p /var/www/html/css
sudo mkdir -p /var/www/html/js
sudo mkdir -p /var/www/html/py
          </pre></div>
          <p>Ajuste as permiss√µes para que o Apache possa servir os arquivos e executar os CGIs. O diret√≥rio <code class="file-path">/var/www/html</code> e seus conte√∫dos geralmente pertencem a <code class="file-path">www-data</code>.</p>
          <div class="code-block"><pre>
sudo chown -R www-data:www-data /var/www/html
sudo chmod -R 755 /var/www/html <span class="comment"># Leitura e execu√ß√£o para todos, escrita para o dono</span>
sudo chmod +x /var/www/html/py/*.py <span class="comment"># Tornar scripts Python execut√°veis</span>
          </pre></div>
        </article>
      </div>
    </section>

    <hr>

    <section id="backend">
      <h2><emoji>üêç</emoji> Backend: Scripts Python</h2>
      <div class="card-container">
        <article class="card">
          <h3>5.1. <code class="file-path">websocket_server.py</code></h3>
          <p>Este √© o cora√ß√£o do backend. Ele usar√° <code class="library">asyncio</code> para lidar com m√∫ltiplas conex√µes e tarefas concorrentemente: escutar TCP na porta 8080, UDP na 8081, e servir WebSockets na 8082.</p>
          <p>Coloque este arquivo em <code class="file-path">/var/www/html/py/websocket_server.py</code>.</p>
          <div class="code-block">
            <pre><span class="keyword">#!/usr/bin/python3</span>
<span class="keyword">import</span> asyncio
<span class="keyword">import</span> websockets
<span class="keyword">import</span> json
<span class="keyword">import</span> datetime
<span class="keyword">import</span> logging
<span class="keyword">import</span> os
<span class="keyword">import</span> signal

logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(message)s')

<span class="variable">TCP_PORT</span> = 8080
<span class="variable">UDP_PORT</span> = 8081
<span class="variable">WEBSOCKET_PORT</span> = 8082
<span class="variable">PID_FILE</span> = "/var/www/html/py/server.pid" <span class="comment"># Usado para gerenciamento do processo</span>

<span class="comment"># Conjunto de clientes WebSocket conectados</span>
<span class="variable">connected_clients</span> = set()

<span class="keyword">async def</span> <span class="function">broadcast_message</span>(message_data):
    <span class="keyword">if</span> connected_clients:
        message_json = json.dumps(message_data)
        await asyncio.wait([client.send(message_json) <span class="keyword">for</span> client <span class="keyword">in</span> connected_clients])
        logging.info(f"Broadcasted: {message_data['type']} from {message_data['ip']} - {message_data['content']}")

<span class="keyword">async def</span> <span class="function">handle_tcp_client</span>(reader, writer):
    addr = writer.get_extra_info('peername')
    client_ip = addr[0]
    logging.info(f"TCP connection from {addr}")
    <span class="keyword">try</span>:
        <span class="keyword">while True</span>:
            data = await reader.read(1024)
            <span class="keyword">if not</span> data:
                <span class="keyword">break</span>
            message_content = data.decode().strip()
            logging.info(f"TCP message from {client_ip}: {message_content}")

            message_data = {
                "type": "TCP",
                "ip": client_ip,
                "port": addr[1],
                "date": datetime.datetime.now().strftime("%Y-%m-%d"),
                "time": datetime.datetime.now().strftime("%H:%M:%S.%f")[:-3],
                "content": message_content
            }
            await broadcast_message(message_data)
            writer.write(f"TCP Message '{message_content}' received by server".encode())
            await writer.drain()
            <span class="keyword">if</span> message_content.lower() <span class="keyword">in</span> ['exit', 'quit']:
                <span class="keyword">break</span>
    <span class="keyword">except</span> ConnectionResetError:
        logging.info(f"TCP connection reset by {addr}")
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        logging.error(f"TCP Error with {addr}: {e}")
    <span class="keyword">finally</span>:
        logging.info(f"Closing TCP connection with {addr}")
        writer.close()
        await writer.wait_closed()

<span class="keyword">class</span> <span class="class">UDPEchoProtocol</span>(asyncio.DatagramProtocol):
    <span class="keyword">def</span> <span class="function">connection_made</span>(self, transport):
        self.transport = transport
        logging.info("UDP listener started.")

    <span class="keyword">def</span> <span class="function">datagram_received</span>(self, data, addr):
        client_ip = addr[0]
        message_content = data.decode().strip()
        logging.info(f"UDP message from {addr}: {message_content}")

        message_data = {
            "type": "UDP",
            "ip": client_ip,
            "port": addr[1],
            "date": datetime.datetime.now().strftime("%Y-%m-%d"),
            "time": datetime.datetime.now().strftime("%H:%M:%S.%f")[:-3],
            "content": message_content
        }
        <span class="comment"># asyncio.create_task para n√£o bloquear o datagram_received</span>
        asyncio.create_task(broadcast_message(message_data))
        self.transport.sendto(f"UDP Message '{message_content}' received by server".encode(), addr)
        <span class="keyword">if</span> message_content.lower() <span class="keyword">in</span> ['exit', 'quit']:
            logging.info(f"UDP client {addr} sent exit command.")
            <span class="comment"># UDP √© sem conex√£o, ent√£o n√£o h√° "fechamento" de conex√£o aqui.</span>

    <span class="keyword">def</span> <span class="function">error_received</span>(self, exc):
        logging.error(f"UDP Error: {exc}")

    <span class="keyword">def</span> <span class="function">connection_lost</span>(self, exc):
        logging.info("UDP listener stopped.")


<span class="keyword">async def</span> <span class="function">websocket_handler</span>(websocket, path):
    connected_clients.add(websocket)
    client_ip = websocket.remote_address[0]
    logging.info(f"WebSocket client connected: {client_ip}")
    <span class="keyword">try</span>:
        <span class="keyword">async for</span> message <span class="keyword">in</span> websocket:
            logging.info(f"WebSocket message from {client_ip}: {message}")
            <span class="comment"># Processar mensagens do cliente WebSocket, se necess√°rio (ex: controle)</span>
            <span class="comment"># Por enquanto, apenas ecoa de volta ou ignora.</span>
            <span class="comment"># await websocket.send(f"Server received: {message}")</span>
    <span class="keyword">except</span> websockets.exceptions.ConnectionClosedOK:
        logging.info(f"WebSocket client disconnected normally: {client_ip}")
    <span class="keyword">except</span> websockets.exceptions.ConnectionClosedError <span class="keyword">as</span> e:
        logging.warning(f"WebSocket client connection error for {client_ip}: {e}")
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        logging.error(f"WebSocket error with {client_ip}: {e}")
    <span class="keyword">finally</span>:
        connected_clients.remove(websocket)
        logging.info(f"WebSocket client disconnected: {client_ip}")

<span class="keyword">async def</span> <span class="function">main</span>():
    loop = asyncio.get_running_loop()

    <span class="comment"># Start TCP server</span>
    tcp_server = await asyncio.start_server(handle_tcp_client, '0.0.0.0', TCP_PORT)
    logging.info(f"TCP Server listening on port {TCP_PORT}...")

    <span class="comment"># Start UDP server</span>
    await loop.create_datagram_endpoint(
        <span class="keyword">lambda</span>: UDPEchoProtocol(),
        local_addr=('0.0.0.0', UDP_PORT)
    )
    logging.info(f"UDP Server listening on port {UDP_PORT}...")

    <span class="comment"># Start WebSocket server</span>
    websocket_server = await websockets.serve(websocket_handler, "0.0.0.0", WEBSOCKET_PORT)
    logging.info(f"WebSocket Server listening on port {WEBSOCKET_PORT}...")
    
    <span class="comment"># Write PID file</span>
    <span class="keyword">with</span> open(PID_FILE, 'w') <span class="keyword">as</span> f:
        f.write(str(os.getpid()))
    logging.info(f"Server PID {os.getpid()} written to {PID_FILE}")

    <span class="comment"># Keep servers running until SIGTERM or SIGINT</span>
    stop_event = asyncio.Event()
    <span class="keyword">def</span> <span class="function">signal_handler</span>(sig, frame):
        logging.info(f"Received signal {sig}, shutting down...")
        stop_event.set()

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)
    
    <span class="keyword">try</span>:
        await stop_event.wait() <span class="comment"># Wait for shutdown signal</span>
    <span class="keyword">finally</span>:
        logging.info("Closing servers...")
        tcp_server.close()
        await tcp_server.wait_closed()
        <span class="comment"># UDP server stops when event loop stops or transport is closed</span>
        websocket_server.close()
        await websocket_server.wait_closed()
        logging.info("All servers closed.")
        <span class="keyword">if</span> os.path.exists(PID_FILE):
            os.remove(PID_FILE)
        logging.info("PID file removed. Exiting.")

<span class="keyword">if</span> __name__ == "__main__":
    <span class="keyword">try</span>:
        asyncio.run(main())
    <span class="keyword">except</span> KeyboardInterrupt:
        logging.info("Server stopped by user (KeyboardInterrupt).")
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        logging.error(f"Failed to start server: {e}")
        <span class="keyword">if</span> os.path.exists(PID_FILE):
            os.remove(PID_FILE)
</pre>
          </div>
        </article>

        <article class="card">
          <h3>5.2. CGI Scripts para Controle do Servidor</h3>
          <p>Estes scripts (<code class="file-path">start_server.py</code>, <code class="file-path">stop_server.py</code>, <code class="file-path">status_server.py</code>) ser√£o chamados pelo JavaScript da p√°gina <code class="file-path">index.html</code> para gerenciar o processo <code class="file-path">websocket_server.py</code>. Coloque-os em <code class="file-path">/var/www/html/py/</code> e torne-os execut√°veis (<code class="file-path">chmod +x</code>).</p>
          <p><strong>Importante:</strong> A execu√ß√£o de comandos de sistema via CGI pelo usu√°rio do Apache (<code class="file-path">www-data</code>) requer permiss√µes cuidadosas e pode ter implica√ß√µes de seguran√ßa. Para um ambiente de produ√ß√£o, usar `systemd` e `sudo` com configura√ß√µes restritas seria mais robusto.</p>

          <h4><code class="file-path">start_server.py</code> (CGI)</h4>
          <div class="code-block"><pre><span class="keyword">#!/usr/bin/python3</span>
<span class="keyword">import</span> subprocess
<span class="keyword">import</span> os
<span class="keyword">import</span> json

SERVER_SCRIPT = "/var/www/html/py/websocket_server.py"
PID_FILE = "/var/www/html/py/server.pid"

print("Content-Type: application/json\n")
response = {"status": "error", "message": ""}

<span class="keyword">if</span> os.path.exists(PID_FILE):
    <span class="keyword">try</span>:
        <span class="keyword">with</span> open(PID_FILE, 'r') <span class="keyword">as</span> f:
            pid = int(f.read().strip())
        os.kill(pid, 0)  <span class="comment"># Check if process exists</span>
        response["status"] = "already_running"
        response["message"] = f"Server is already running with PID {pid}."
        print(json.dumps(response))
        exit()
    <span class="keyword">except</span> (IOError, ValueError, OSError):
        os.remove(PID_FILE) <span class="comment"># Stale PID file</span>

<span class="keyword">try</span>:
    <span class="comment"># Ensure the script is executable and has correct shebang, or run with python3 explicitly</span>
    process = subprocess.Popen(['python3', SERVER_SCRIPT], start_new_session=<span class="keyword">True</span>)
    <span class="comment"># PID is written by websocket_server.py itself now</span>
    response["status"] = "starting"
    response["message"] = f"Server starting (PID will be in {PID_FILE} shortly)."
<span class="keyword">except</span> Exception <span class="keyword">as</span> e:
    response["message"] = f"Error starting server: {str(e)}"

print(json.dumps(response))
</pre></div>

          <h4><code class="file-path">stop_server.py</code> (CGI)</h4>
          <div class="code-block"><pre><span class="keyword">#!/usr/bin/python3</span>
<span class="keyword">import</span> os
<span class="keyword">import</span> signal
<span class="keyword">import</span> json

PID_FILE = "/var/www/html/py/server.pid"

print("Content-Type: application/json\n")
response = {"status": "error", "message": ""}

<span class="keyword">if not</span> os.path.exists(PID_FILE):
    response["status"] = "not_running"
    response["message"] = "Server PID file not found. Is the server running?"
    print(json.dumps(response))
    exit()

<span class="keyword">try</span>:
    <span class="keyword">with</span> open(PID_FILE, 'r') <span class="keyword">as</span> f:
        pid = int(f.read().strip())
    os.kill(pid, signal.SIGTERM)  <span class="comment"># Send TERM signal (graceful shutdown)</span>
    response["status"] = "stopping"
    response["message"] = f"Stop signal (SIGTERM) sent to server with PID {pid}. PID file will be removed by server."
    <span class="comment"># PID file is removed by websocket_server.py on exit</span>
<span class="keyword">except</span> (IOError, ValueError):
    response["message"] = "Error reading PID file. It might be corrupted."
    <span class="keyword">if</span> os.path.exists(PID_FILE): os.remove(PID_FILE)
<span class="keyword">except</span> ProcessLookupError:
    response["status"] = "not_running"
    response["message"] = f"Process with PID {pid} not found. Removing stale PID file."
    <span class="keyword">if</span> os.path.exists(PID_FILE): os.remove(PID_FILE)
<span class="keyword">except</span> Exception <span class="keyword">as</span> e:
    response["message"] = f"Error stopping server: {str(e)}"

print(json.dumps(response))
</pre></div>

          <h4><code class="file-path">status_server.py</code> (CGI)</h4>
          <div class="code-block"><pre><span class="keyword">#!/usr/bin/python3</span>
<span class="keyword">import</span> os
<span class="keyword">import</span> json

PID_FILE = "/var/www/html/py/server.pid"

print("Content-Type: application/json\n")
status_info = {"status": "offline", "pid": <span class="keyword">None</span>, "message": "Server is offline."}

<span class="keyword">if</span> os.path.exists(PID_FILE):
    <span class="keyword">try</span>:
        <span class="keyword">with</span> open(PID_FILE, 'r') <span class="keyword">as</span> f:
            pid = int(f.read().strip())
        os.kill(pid, 0)  <span class="comment"># Check if process exists by sending signal 0</span>
        status_info["status"] = "online"
        status_info["pid"] = pid
        status_info["message"] = f"Server is online with PID {pid}."
    <span class="keyword">except</span> (IOError, ValueError):
        status_info["message"] = "PID file found but seems corrupted."
        status_info["status"] = "error"
    <span class="keyword">except</span> ProcessLookupError:
        status_info["message"] = "PID file found, but process is not running (stale PID)."
        status_info["status"] = "offline_stale_pid"
        <span class="comment"># Attempt to clean up stale PID file (optional, handle permissions)</span>
        <span class="comment"># try: os.remove(PID_FILE) except OSError: pass</span>
    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:
        status_info["message"] = f"Error checking server status: {str(e)}"
        status_info["status"] = "error"
<span class="keyword">else</span>:
    status_info["message"] = "Server is offline (PID file not found)."
    status_info["status"] = "offline"

print(json.dumps(status_info))
</pre></div>
        </article>
      </div>
    </section>

    <hr>

    <section id="frontend">
      <h2><emoji>üåê</emoji> Frontend: HTML e JavaScript (para a Atividade)</h2>
      <p>Estes arquivos comp√µem a interface do monitor de mensagens. O CSS √© fornecido (<code class="file-path">ws.css</code>).</p>
      <div class="card-container">
        <article class="card">
          <h3>6.1. <code class="file-path">index.html</code> (Interface do Monitor)</h3>
          <p>Local: <code class="file-path">/var/www/html/index.html</code>. Este arquivo usa <code class="file-path">ws.css</code>.</p>
          <div class="code-block"><pre><span class="keyword">&lt;!DOCTYPE html&gt;</span>
&lt;html lang="pt-BR"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Monitor de Mensagens TCP/UDP&lt;/title&gt;
    &lt;link rel="stylesheet" href="css/ws.css"&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div <span class="keyword">class</span>="container"&gt;
        &lt;header&gt;
            &lt;h1&gt;Monitor de Mensagens TCP/UDP&lt;/h1&gt;
        &lt;/header&gt;

        &lt;div <span class="keyword">class</span>="server-status"&gt;
            &lt;div <span class="keyword">class</span>="status-indicator"&gt;
                &lt;span <span class="keyword">id</span>="statusDot" <span class="keyword">class</span>="status-dot status-offline"&gt;&lt;/span&gt;
                &lt;span <span class="keyword">id</span>="statusText"&gt;Servidor Offline&lt;/span&gt;
            &lt;/div&gt;
            &lt;div <span class="keyword">class</span>="server-controls"&gt;
                &lt;button <span class="keyword">id</span>="startServerBtn"&gt;Iniciar Servidor&lt;/button&gt;
                &lt;button <span class="keyword">id</span>="stopServerBtn"&gt;Parar Servidor&lt;/button&gt;
                &lt;button <span class="keyword">id</span>="clearMessagesBtn"&gt;Limpar Mensagens&lt;/button&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div <span class="keyword">class</span>="connection-stats"&gt;
            &lt;div <span class="keyword">class</span>="stat-card"&gt;
                &lt;h3&gt;TCP&lt;/h3&gt;
                &lt;p <span class="keyword">class</span>="count" <span class="keyword">id</span>="tcpCount"&gt;0&lt;/p&gt;
            &lt;/div&gt;
            &lt;div <span class="keyword">class</span>="stat-card"&gt;
                &lt;h3&gt;UDP&lt;/h3&gt;
                &lt;p <span class="keyword">class</span>="count" <span class="keyword">id</span>="udpCount"&gt;0&lt;/p&gt;
            &lt;/div&gt;
            &lt;div <span class="keyword">class</span>="stat-card"&gt;
                &lt;h3&gt;Total&lt;/h3&gt;
                &lt;p <span class="keyword">class</span>="count" <span class="keyword">id</span>="totalCount"&gt;0&lt;/p&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div <span class="keyword">class</span>="messages-container"&gt;
            &lt;div <span class="keyword">class</span>="message-tabs"&gt;
                &lt;span <span class="keyword">class</span>="tab active" <span class="keyword">data-filter</span>="all"&gt;Todas&lt;/span&gt;
                &lt;span <span class="keyword">class</span>="tab" <span class="keyword">data-filter</span>="tcp"&gt;TCP&lt;/span&gt;
                &lt;span <span class="keyword">class</span>="tab" <span class="keyword">data-filter</span>="udp"&gt;UDP&lt;/span&gt;
            &lt;/div&gt;
            &lt;div <span class="keyword">class</span>="message-list" <span class="keyword">id</span>="messageList"&gt;
                &lt;!-- Mensagens ser√£o inseridas aqui --&gt;
                &lt;div <span class="keyword">class</span>="no-messages"&gt;Nenhuma mensagem recebida ainda.&lt;/div&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;div&gt;
            &lt;span <span class="keyword">class</span>="debug-toggle" <span class="keyword">id</span>="toggleDebugBtn"&gt;Mostrar Informa√ß√µes de Depura√ß√£o&lt;/span&gt;
            &lt;div <span class="keyword">class</span>="debug-info" <span class="keyword">id</span>="debugInfo"&gt;
                &lt;!-- Logs de depura√ß√£o ser√£o inseridos aqui --&gt;
            &lt;/div&gt;
        &lt;/div&gt;

        &lt;footer&gt;
            &lt;p&gt;Atividade Avaliativa 11 - INE5646 - Programa√ß√£o para Web&lt;/p&gt;
        &lt;/footer&gt;
    &lt;/div&gt;

    &lt;script src="js/ws.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</pre></div>
        </article>

        <article class="card">
          <h3>6.2. <code class="file-path">ws.js</code> (L√≥gica do Cliente)</h3>
          <p>Local: <code class="file-path">/var/www/html/js/ws.js</code>.</p>
          <p><strong>Nota:</strong> Substitua <code class="file-path">websocket.seu_idUFSC.vms.ufsc.br</code> pelo URL correto do seu servidor.</p>
          <div class="code-block"><pre>
document.addEventListener('DOMContentLoaded', () => {
    <span class="keyword">const</span> statusDot = document.getElementById('statusDot');
    <span class="keyword">const</span> statusText = document.getElementById('statusText');
    <span class="keyword">const</span> startServerBtn = document.getElementById('startServerBtn');
    <span class="keyword">const</span> stopServerBtn = document.getElementById('stopServerBtn');
    <span class="keyword">const</span> clearMessagesBtn = document.getElementById('clearMessagesBtn');
    <span class="keyword">const</span> messageList = document.getElementById('messageList');
    <span class="keyword">const</span> tcpCountElem = document.getElementById('tcpCount');
    <span class="keyword">const</span> udpCountElem = document.getElementById('udpCount');
    <span class="keyword">const</span> totalCountElem = document.getElementById('totalCount');
    <span class="keyword">const</span> debugInfo = document.getElementById('debugInfo');
    <span class="keyword">const</span> toggleDebugBtn = document.getElementById('toggleDebugBtn');
    <span class="keyword">const</span> messageTabs = document.querySelectorAll('.message-tabs .tab');

    <span class="keyword">let</span> websocket;
    <span class="keyword">let</span> tcpMessages = 0;
    <span class="keyword">let</span> udpMessages = 0;
    <span class="keyword">let</span> currentFilter = 'all';
    <span class="keyword">let</span> debugVisible = <span class="keyword">false</span>;

    <span class="comment">// Substitua 'seu_idUFSC' pelo seu identificador UFSC.</span>
    <span class="comment">// A porta 8082 √© a porta do WebSocket definida no servidor Python.</span>
    <span class="keyword">const</span> WEBSOCKET_URL = `ws://websocket.e.w.giacomelli.vms.ufsc.br:8082`; <span class="comment">//  &lt;-- AJUSTE AQUI SEU IDUFSC</span>
    <span class="keyword">const</span> CGI_BASE_PATH = '/cgi-bin/'; <span class="comment">// Caminho para os scripts CGI conforme configurado no Apache</span>

    <span class="keyword">function</span> <span class="function">addDebugLog</span>(message) {
        <span class="keyword">const</span> timestamp = <span class="keyword">new</span> Date().toISOString();
        <span class="keyword">const</span> logEntry = document.createElement('div');
        logEntry.textContent = `[${timestamp}] ${message}`;
        debugInfo.appendChild(logEntry);
        debugInfo.scrollTop = debugInfo.scrollHeight; <span class="comment">// Auto-scroll</span>
    }

    <span class="keyword">function</span> <span class="function">updateServerStatus</span>(status, message) {
        statusText.textContent = message;
        statusDot.className = 'status-dot'; <span class="comment">// Reset classes</span>
        <span class="keyword">switch</span> (status) {
            <span class="keyword">case</span> 'online':
                statusDot.classList.add('status-online');
                <span class="keyword">break</span>;
            <span class="keyword">case</span> 'offline':
                statusDot.classList.add('status-offline');
                <span class="keyword">break</span>;
            <span class="keyword">case</span> 'connecting':
            <span class="keyword">case</span> 'starting':
                statusDot.classList.add('status-offline'); <span class="comment">// Visually offline or neutral</span>
                <span class="comment">// Potentially add a 'status-connecting' class if defined in CSS</span>
                <span class="keyword">break</span>;
            <span class="keyword">default</span>:
                statusDot.classList.add('status-offline');
        }
        addDebugLog(`Status do Servidor: ${message} (Estado: ${status})`);
    }
    
    <span class="keyword">function</span> <span class="function">connectWebSocket</span>() {
        <span class="keyword">if</span> (websocket && websocket.readyState === WebSocket.OPEN) {
            addDebugLog("WebSocket j√° est√° conectado.");
            <span class="keyword">return</span>;
        }

        updateServerStatus('connecting', 'Conectando ao WebSocket...');
        websocket = <span class="keyword">new</span> WebSocket(WEBSOCKET_URL);

        websocket.onopen = () => {
            updateServerStatus('online', 'Conectado ao Servidor WebSocket');
            addDebugLog(`WebSocket conectado a: ${WEBSOCKET_URL}`);
        };

        websocket.onmessage = (event) => {
            <span class="keyword">try</span> {
                <span class="keyword">const</span> msgData = JSON.parse(event.data);
                addMessageToList(msgData);
                updateCounters(msgData.type);
                addDebugLog(`Mensagem recebida: ${JSON.stringify(msgData)}`);
            } <span class="keyword">catch</span> (error) {
                addDebugLog(`Erro ao processar mensagem: ${event.data}. Erro: ${error}`);
            }
        };

        websocket.onerror = (error) => {
            updateServerStatus('offline', 'Erro no WebSocket');
            addDebugLog(`WebSocket Error: ${JSON.stringify(error)}`);
        };

        websocket.onclose = (event) => {
            updateServerStatus('offline', 'Desconectado do Servidor WebSocket');
            addDebugLog(`WebSocket desconectado. C√≥digo: ${event.code}, Raz√£o: ${event.reason || 'N/A'}`);
            <span class="comment">// Poderia tentar reconectar aqui se desejado</span>
        };
    }

    <span class="keyword">function</span> <span class="function">disconnectWebSocket</span>() {
        <span class="keyword">if</span> (websocket) {
            websocket.close();
            addDebugLog("Comando para desconectar WebSocket enviado.");
        }
    }

    <span class="keyword">function</span> <span class="function">callCgiScript</span>(scriptName, successCallback, errorCallback) {
        updateServerStatus('starting', `Executando ${scriptName}...`);
        fetch(`${CGI_BASE_PATH}${scriptName}`)
            .then(response => {
                <span class="keyword">if</span> (!response.ok) {
                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(`HTTP error! status: ${response.status}`);
                }
                <span class="keyword">return</span> response.json();
            })
            .then(data => {
                addDebugLog(`Resposta de ${scriptName}: ${JSON.stringify(data)}`);
                <span class="keyword">if</span> (successCallback) successCallback(data);
            })
            .catch(error => {
                addDebugLog(`Erro ao chamar ${scriptName}: ${error}`);
                updateServerStatus('error', `Erro ao executar ${scriptName}`);
                <span class="keyword">if</span> (errorCallback) errorCallback(error);
            });
    }
    
    startServerBtn.addEventListener('click', () => {
        addDebugLog("Solicitando in√≠cio do servidor Python...");
        callCgiScript('start_server.py', (data) => {
            updateServerStatus(data.status, data.message);
            <span class="keyword">if</span> (data.status === 'starting' || data.status === 'already_running') {
                <span class="comment">// Tenta conectar ao WebSocket ap√≥s um pequeno delay para o servidor Python iniciar</span>
                setTimeout(connectWebSocket, 2000); 
            }
        });
    });

    stopServerBtn.addEventListener('click', () => {
        addDebugLog("Solicitando parada do servidor Python...");
        disconnectWebSocket(); <span class="comment">// Primeiro desconecta o WebSocket</span>
        callCgiScript('stop_server.py', (data) => {
            updateServerStatus(data.status === 'stopping' || data.status === 'not_running' ? 'offline' : 'error', data.message);
        });
    });
    
    <span class="keyword">function</span> <span class="function">checkServerStatusPeriodically</span>() {
        callCgiScript('status_server.py', (data) => {
            <span class="keyword">if</span> (data.status === 'online') {
                <span class="keyword">if</span> (!websocket || websocket.readyState === WebSocket.CLOSED) {
                    connectWebSocket(); <span class="comment">// Se o servidor est√° online mas n√£o estamos conectados, conectar.</span>
                } <span class="keyword">else if</span> (websocket && websocket.readyState === WebSocket.OPEN) {
                     updateServerStatus('online', `Servidor Online (PID: ${data.pid}) - Conectado ao WS`);
                }
            } <span class="keyword">else</span> { <span class="comment">// offline, error, offline_stale_pid</span>
                <span class="keyword">if</span> (websocket && websocket.readyState === WebSocket.OPEN) {
                    disconnectWebSocket(); <span class="comment">// Se o servidor Python caiu, fechar a conex√£o WS</span>
                }
                updateServerStatus('offline', data.message || 'Servidor Python Offline');
            }
        }, (error) => {
            updateServerStatus('error', 'Falha ao verificar status do servidor Python.');
             <span class="keyword">if</span> (websocket && websocket.readyState === WebSocket.OPEN) {
                disconnectWebSocket();
            }
        });
    }


    clearMessagesBtn.addEventListener('click', () => {
        messageList.innerHTML = '&lt;div <span class="keyword">class</span>="no-messages"&gt;Mensagens limpas.&lt;/div&gt;';
        tcpMessages = 0;
        udpMessages = 0;
        updateCounters(null); <span class="comment">// Reseta contadores</span>
        addDebugLog("Mensagens limpas.");
    });

    toggleDebugBtn.addEventListener('click', () => {
        debugVisible = !debugVisible;
        debugInfo.style.display = debugVisible ? 'block' : 'none';
        toggleDebugBtn.textContent = debugVisible ? 'Ocultar Informa√ß√µes de Depura√ß√£o' : 'Mostrar Informa√ß√µes de Depura√ß√£o';
    });

    <span class="keyword">function</span> <span class="function">addMessageToList</span>(msgData) {
        <span class="keyword">if</span> (messageList.querySelector('.no-messages')) {
            messageList.innerHTML = ''; <span class="comment">// Remove "Nenhuma mensagem"</span>
        }

        <span class="keyword">const</span> messageDiv = document.createElement('div');
        messageDiv.classList.add('message', msgData.type.toLowerCase());
        messageDiv.setAttribute('data-type', msgData.type.toLowerCase());

        <span class="keyword">const</span> header = document.createElement('div');
        header.classList.add('message-header');

        <span class="keyword">const</span> protocolBadge = document.createElement('span');
        protocolBadge.classList.add('protocol-badge', `${msgData.type.toLowerCase()}-badge`);
        protocolBadge.textContent = msgData.type;

        <span class="keyword">const</span> clientInfo = document.createElement('span');
        clientInfo.textContent = `IP: ${msgData.ip}:${msgData.port}`;

        <span class="keyword">const</span> dateTime = document.createElement('span');
        dateTime.textContent = `${msgData.date} ${msgData.time}`;

        header.appendChild(protocolBadge);
        header.appendChild(clientInfo);
        header.appendChild(dateTime);

        <span class="keyword">const</span> content = document.createElement('div');
        content.classList.add('message-content');
        content.textContent = msgData.content;

        messageDiv.appendChild(header);
        messageDiv.appendChild(content);

        messageList.appendChild(messageDiv);
        messageList.scrollTop = messageList.scrollHeight; <span class="comment">// Auto-scroll</span>

        applyFilter(); <span class="comment">// Re-aplica o filtro para o caso de a nova mensagem n√£o corresponder</span>
    }

    <span class="keyword">function</span> <span class="function">updateCounters</span>(type) {
        <span class="keyword">if</span> (type === 'TCP') tcpMessages++;
        <span class="keyword">if</span> (type === 'UDP') udpMessages++;
        
        tcpCountElem.textContent = tcpMessages;
        udpCountElem.textContent = udpMessages;
        totalCountElem.textContent = tcpMessages + udpMessages;
    }

    messageTabs.forEach(tab => {
        tab.addEventListener('click', () => {
            messageTabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            currentFilter = tab.getAttribute('data-filter');
            applyFilter();
            addDebugLog(`Filtro alterado para: ${currentFilter}`);
        });
    });

    <span class="keyword">function</span> <span class="function">applyFilter</span>() {
        <span class="keyword">const</span> messages = messageList.querySelectorAll('.message');
        messages.forEach(msg => {
            <span class="keyword">if</span> (currentFilter === 'all' || msg.getAttribute('data-type') === currentFilter) {
                msg.style.display = '';
            } <span class="keyword">else</span> {
                msg.style.display = 'none';
            }
        });
    }

    <span class="comment">// Inicializa√ß√£o</span>
    addDebugLog("Cliente JavaScript inicializado.");
    updateServerStatus('offline', 'Aguardando a√ß√£o...'); 
    checkServerStatusPeriodically(); <span class="comment">// Verifica o status do servidor Python ao carregar</span>
    setInterval(checkServerStatusPeriodically, 15000); <span class="comment">// E periodicamente a cada 15 segundos</span>
});
</pre></div>
        </article>
      </div>
    </section>

    <hr>

    <section id="execucao">
      <h2><emoji>üöÄ</emoji> Execu√ß√£o da Aplica√ß√£o</h2>
      <div class="card-container">
        <article class="card">
          <h3>Iniciando o Servidor e Testando</h3>
          <ol>
            <li>
              <strong>Acesse a P√°gina do Monitor:</strong>
              Abra seu navegador e v√° para <code class="file-path">http://websocket.seu_idUFSC.vms.ufsc.br/</code>.
            </li>
            <li>
              <strong>Inicie o Servidor Python:</strong>
              Clique no bot√£o "Iniciar Servidor" na p√°gina. Isso chamar√° o script CGI <code class="file-path">start_server.py</code>, que tentar√° executar <code class="file-path">websocket_server.py</code> em segundo plano. O status do servidor na p√°gina deve mudar. O WebSocket tentar√° se conectar automaticamente.
              <p><em>Alternativamente (para depura√ß√£o ou se o CGI falhar):</em> Voc√™ pode iniciar <code class="file-path">websocket_server.py</code> manualmente via SSH:
              <div class="code-block"><pre>cd /var/www/html/py/
python3 websocket_server.py</pre></div>
              Neste caso, para rodar em background e persistir ap√≥s fechar o SSH, use `nohup` e `&`:
              <div class="code-block"><pre>cd /var/www/html/py/
nohup python3 websocket_server.py > server.log 2>&1 &</pre></div>
              Para parar um servidor iniciado manualmente, voc√™ precisar√° encontrar o PID (ex: <code class="file-path">ps aux | grep websocket_server.py</code>) e usar <code class="file-path">kill [PID]</code>. O script <code class="file-path">websocket_server.py</code> foi projetado para lidar com SIGTERM e limpar seu arquivo PID.
              </p>
            </li>
            <li>
              <strong>Envie Mensagens TCP/UDP:</strong>
              Use os scripts <code class="file-path">tcp_client.py</code> e <code class="file-path">udp_client.py</code> fornecidos. Execute-os em sua m√°quina local (ou em outro terminal SSH conectado ao VPS, se quiser testar localmente no servidor).
              <p>Ao executar os clientes, informe a URL do <strong>seu servidor WebSocket</strong> quando solicitado (ex: <code class="file-path">websocket.seu_idUFSC.vms.ufsc.br</code>). Os clientes usar√£o as portas 8080 (TCP) e 8081 (UDP) por padr√£o, conforme especificado.</p>
              <div class="code-block"><pre>
<span class="comment"># Na sua m√°quina local ou outro terminal</span>
python3 tcp_client.py
<span class="comment"># Quando pedir a URL, digite: websocket.seu_idUFSC.vms.ufsc.br</span>
<span class="comment"># (O script j√° tem as portas 8080/8081 como padr√£o se s√≥ o host for dado)</span>

python3 udp_client.py
<span class="comment"># URL: websocket.seu_idUFSC.vms.ufsc.br</span>
              </pre></div>
            </li>
            <li>
              <strong>Visualize as Mensagens:</strong>
              As mensagens enviadas devem aparecer na p√°gina do monitor em tempo real, com suas respectivas flags (TCP/UDP), IP do cliente, data e hora.
            </li>
            <li>
                <strong>Controles da Interface:</strong>
                <ul>
                    <li><strong>Parar Servidor:</strong> Tenta parar o processo <code class="file-path">websocket_server.py</code> via CGI e desconecta o WebSocket.</li>
                    <li><strong>Limpar Mensagens:</strong> Limpa a lista de mensagens na interface.</li>
                    <li><strong>Filtros (Todas, TCP, UDP):</strong> Filtra as mensagens exibidas.</li>
                    <li><strong>Contadores:</strong> Mostram o n√∫mero de mensagens TCP, UDP e totais.</li>
                    <li><strong>Informa√ß√µes de Depura√ß√£o:</strong> Mostra/oculta logs do cliente JavaScript.</li>
                </ul>
            </li>
          </ol>
        </article>
      </div>
    </section>

    <hr>

    <section id="deploy-edicao">
      <h2><emoji>üì¶</emoji> Deploy e Edi√ß√£o de Arquivos no Servidor</h2>
      <div class="card-container">
        <article class="card">
          <h3>Enviando Arquivos para o VPS</h3>
          <p>Voc√™ pode enviar os arquivos para o seu VPS de algumas maneiras:</p>
          <ul>
            <li>
              <strong><code class="file-path">scp</code> (Secure Copy):</strong>
              <p>Para enviar um arquivo:</p>
              <div class="code-block"><pre>scp caminho/local/do/arquivo.py seu_idUFSC@websocket.seu_idUFSC.vms.ufsc.br:/var/www/html/py/</pre></div>
              <p>Para enviar um diret√≥rio recursivamente (ex: sua pasta <code class="file-path">js</code>):</p>
              <div class="code-block"><pre>scp -r caminho/local/da/pasta_js seu_idUFSC@websocket.seu_idUFSC.vms.ufsc.br:/var/www/html/</pre></div>
            </li>
            <li>
              <strong><code class="file-path">rsync</code>:</strong>
              Similar ao `scp`, mas mais eficiente para transfer√™ncias repetidas, pois sincroniza apenas as diferen√ßas.
              <div class="code-block"><pre>rsync -avz caminho/local/do/projeto/ seu_idUFSC@websocket.seu_idUFSC.vms.ufsc.br:/var/www/html/</pre></div>
            </li>
          </ul>
        </article>
        <article class="card">
          <h3>Editando Arquivos com VS Code (Remote - SSH)</h3>
          <p>Uma forma muito conveniente de editar os arquivos diretamente no servidor √© usando a extens√£o <strong>Remote - SSH</strong> do Visual Studio Code.</p>
          <ol>
            <li><strong>Instale a Extens√£o:</strong> No VS Code, v√° para a aba de Extens√µes (Ctrl+Shift+X) e procure por "Remote - SSH" (da Microsoft). Instale-a.</li>
            <li><strong>Conecte-se ao Host:</strong>
              <ul>
                <li>Pressione F1 (ou Ctrl+Shift+P) para abrir a paleta de comandos.</li>
                <li>Digite "Remote-SSH: Connect to Host..." e selecione.</li>
                <li>Escolha "+ Add New SSH Host...".</li>
                <li>Digite o comando SSH completo: <code class="file-path">ssh seu_idUFSC@websocket.seu_idUFSC.vms.ufsc.br</code></li>
                <li>Escolha um arquivo de configura√ß√£o SSH para salvar (geralmente o padr√£o do seu usu√°rio).</li>
                <li>Ap√≥s adicionar, conecte-se ao host selecionando-o na lista que aparece (ou novamente via "Connect to Host...").</li>
              </ul>
            </li>
            <li><strong>Abra a Pasta do Projeto:</strong> Uma vez conectado, uma nova janela do VS Code se abrir√° no contexto remoto. Clique em "Open Folder" e navegue at√© <code class="file-path">/var/www/html/</code>.</li>
            <li><strong>Edite os Arquivos:</strong> Agora voc√™ pode editar os arquivos como se estivessem na sua m√°quina local. As altera√ß√µes s√£o salvas diretamente no servidor. O terminal integrado do VS Code (Ctrl+`) tamb√©m estar√° conectado ao servidor.</li>
          </ol>
        </article>
      </div>
    </section>

    <hr>

    <section id="bonus-wss">
      <h2><emoji>üåü</emoji> B√¥nus: Implementando WebSocket Seguro (WSS) com HTTPS</h2>
      <div class="card-container">
        <article class="card">
          <h3>Vis√£o Geral</h3>
          <p>Para o b√¥nus, voc√™ implementar√° WebSockets seguros (<code class="file-path">wss://</code>) sobre HTTPS. Isso envolve configurar o Apache para SSL/TLS e, possivelmente, o servidor WebSocket Python para usar certificados SSL, embora o Apache possa lidar com a termina√ß√£o SSL.</p>
          <p>Os certificados podem ser autoassinados para esta atividade.</p>
          <h3>Passos Detalhados:</h3>
          <dl>
            <dt>1. Gerar Certificados Autoassinados (no VPS):</dt>
            <dd>
              Use OpenSSL para criar uma chave privada e um certificado.
              <div class="code-block"><pre>
sudo openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
-keyout /etc/ssl/private/apache-selfsigned.key \
-out /etc/ssl/certs/apache-selfsigned.crt
              </pre></div>
              Voc√™ ser√° solicitado a preencher informa√ß√µes para o certificado. Para "Common Name (e.g. server FQDN or YOUR name)", use seu dom√≠nio: <code class="file-path">websocket.seu_idUFSC.vms.ufsc.br</code>.
              <br>Ajuste as permiss√µes:
              <div class="code-block"><pre>
sudo chmod 600 /etc/ssl/private/apache-selfsigned.key
sudo chmod 644 /etc/ssl/certs/apache-selfsigned.crt
              </pre></div>
            </dd>

            <dt>2. Configurar Apache para SSL/TLS (HTTPS):</dt>
            <dd>
              Crie ou modifique um arquivo de configura√ß√£o do VirtualHost para a porta 443. Pode ser <code class="file-path">/etc/apache2/sites-available/000-default-ssl.conf</code> ou modificar o existente.
              <div class="code-block"><pre><span class="keyword">&lt;IfModule mod_ssl.c&gt;</span>
    <span class="keyword">&lt;VirtualHost _default_:443&gt;</span>
        ServerAdmin seu_email@ufsc.br
        ServerName websocket.seu_idUFSC.vms.ufsc.br
        DocumentRoot /var/www/html

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

        SSLEngine on
        SSLCertificateFile      /etc/ssl/certs/apache-selfsigned.crt
        SSLCertificateKeyFile   /etc/ssl/private/apache-selfsigned.key

        <span class="comment"># Configura√ß√µes de diret√≥rio (semelhantes √† porta 80)</span>
        <span class="keyword">&lt;Directory "/var/www/html"&gt;</span>
            Options -Indexes +FollowSymLinks
            DirectoryIndex index.html
            AllowOverride None
            Require all granted
        <span class="keyword">&lt;/Directory&gt;</span>
        ScriptAlias /cgi-bin/ /var/www/html/py/
        <span class="keyword">&lt;Directory "/var/www/html/py/"&gt;</span>
            Options +ExecCGI -Indexes
            AddHandler cgi-script .py
            Require all granted
        <span class="keyword">&lt;/Directory&gt;</span>

        <span class="comment"># Proxy para WebSocket Seguro (WSS)</span>
        <span class="comment"># O servidor Python websocket_server.py ainda roda sem SSL na porta 8082.</span>
        <span class="comment"># Apache lida com o SSL e encaminha como WS normal para o backend.</span>
        ProxyPreserveHost On
        ProxyRequests Off
        ProxyPass /ws ws://127.0.0.1:8082/
        ProxyPassReverse /ws ws://127.0.0.1:8082/
        <span class="comment"># Se o servidor Python tamb√©m for configurado para WSS na 8082 (mais complexo):</span>
        <span class="comment"># ProxyPass /ws wss://127.0.0.1:8082/</span>
        <span class="comment"># ProxyPassReverse /ws wss://127.0.0.1:8082/</span>
        <span class="comment"># SSLProxyEngine On # Necess√°rio se o backend for WSS</span>

    <span class="keyword">&lt;/VirtualHost&gt;</span>
<span class="keyword">&lt;/IfModule&gt;</span></pre></div>
              Habilite o m√≥dulo SSL e o site SSL:
              <div class="code-block"><pre>
sudo a2enmod ssl
sudo a2enmod headers <span class="comment"># √ötil para HSTS, etc.</span>
sudo a2ensite 000-default-ssl.conf <span class="comment"># Ou o nome do seu arquivo de config SSL</span>
sudo systemctl restart apache2</pre></div>
            </dd>

            <dt>3. Atualizar JavaScript para Usar WSS:</dt>
            <dd>
              Em <code class="file-path">ws.js</code>, mude a URL do WebSocket para <code class="file-path">wss://</code> e a porta para 443 (ou sem porta se o proxy for na raiz <code class="file-path">/ws</code>):
              <div class="code-block"><pre><span class="comment">// Se Apache est√° fazendo proxy de /ws na porta 443 para ws://localhost:8082</span>
<span class="keyword">const</span> WEBSOCKET_URL = `wss://websocket.seu_idUFSC.vms.ufsc.br/ws`;
<span class="comment">// Se voc√™ for conectar diretamente na 8082 e o Python server estiver com SSL:</span>
<span class="comment">// const WEBSOCKET_URL = `wss://websocket.seu_idUFSC.vms.ufsc.br:8082`;</span></pre></div>
              Como estamos usando Apache para terminar o SSL e passar para o Python como WS normal, a primeira op√ß√£o √© a mais simples (Apache faz WSS -> WS).
            </dd>

            <dt>4. (Opcional) Configurar Servidor Python para WSS direto (mais avan√ßado):</dt>
            <dd>
              Se o Apache n√£o for fazer a termina√ß√£o SSL para o WebSocket (ou seja, voc√™ quer que o Python escute em WSS), voc√™ precisaria modificar <code class="file-path">websocket_server.py</code> para usar um contexto SSL.
              <div class="code-block"><pre><span class="comment"># Em websocket_server.py, na fun√ß√£o main():</span>
<span class="keyword">import</span> ssl

ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)
ssl_context.load_cert_chain('/etc/ssl/certs/apache-selfsigned.crt', '/etc/ssl/private/apache-selfsigned.key')

<span class="comment"># ... e ao iniciar o servidor WebSocket:</span>
websocket_server = await websockets.serve(websocket_handler, "0.0.0.0", WEBSOCKET_PORT, ssl=ssl_context)
              </pre></div>
              Neste caso, o Apache faria proxy para `wss://127.0.0.1:8082/`. Para o escopo da atividade, deixar o Apache lidar com SSL (WSS -> WS) √© mais simples.
            </dd>
            <dt>5. Testar:</dt>
            <dd>
                Acesse sua p√°gina via <code class="file-path">https://websocket.seu_idUFSC.vms.ufsc.br</code>. O navegador mostrar√° um aviso sobre certificado autoassinado; voc√™ precisar√° aceitar o risco para continuar. A conex√£o WebSocket dever√° ser estabelecida via WSS.
            </dd>
          </dl>
        </article>
      </div>
    </section>
  </main>

  <footer>
    <address>
      <h3>Quem somos n√≥s</h3>
      <p>Eduardo Wallner Giacomelli</p>
      <p>Matias Adrian Fuks</p>
      <h4>Disciplina</h4>
      <p>INE5646 - Programa√ß√£o para Web</p>
      <h4>Moodle da disciplina:</h4>
      <p><a href="https://presencial.moodle.ufsc.br/course/view.php?id=22229&section=0" target="_blank">Moodle</a></p>
    </address>
    <p>¬© 2025 INE5646. Todos os direitos reservados.</p>
  </footer>
</body>
</html>
